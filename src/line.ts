import * as vexflow from 'vexflow';
import { Factory } from './factory';

/** DO NOT EXPORT: This is a mechanism to validate that an outcome was generated by Line.propose */
const AUTH_TOKEN = Symbol('AUTH_TOKEN');

/** The outcomes of proposing a new system to the line. */
export type ProposalOutcome = AcceptedProposalOutcome | NewlineProposalOutcome | ImpossibleProposalOutcome;

type AcceptedProposalOutcome = {
  readonly token: typeof AUTH_TOKEN;
  type: 'accepted';
  system: vexflow.System;
};

type NewlineProposalOutcome = {
  readonly token: typeof AUTH_TOKEN;
  type: 'newline';
  system: vexflow.System;
};

type ImpossibleProposalOutcome = {
  readonly token: typeof AUTH_TOKEN;
  type: 'impossible';
  explanation: string;
};

/**
 * Line represents a group of VexFlow systems that occupy the same horizontal space.
 *
 * It encapsulates the logic for determining if a new system should be added to the existing line or if a new one should
 * be created. In the latter case, we need to evenly redistribute the remaining empty space to occupy the entire SVG
 * width.
 *
 * The proposal design was used to make caller explicitly aware of line changes.
 */
export class Line {
  /** Creates a new line from a factory. */
  static create(factory: Factory): Line {
    return new Line(factory, []);
  }

  private factory: Factory;
  private systems: vexflow.System[];

  private constructor(factory: Factory, systems: vexflow.System[]) {
    this.factory = factory;
    this.systems = systems;
  }

  /** Proposes a system to be added to the line. */
  propose(system: vexflow.System): ProposalOutcome {
    const systemWidth = this.getSystemWidth(system);
    const rendererWidth = this.factory.getRendererWidth();
    const totalWidth = this.getTotalWidth();

    if (systemWidth > rendererWidth) {
      return {
        token: AUTH_TOKEN,
        type: 'impossible',
        explanation: `proposed system width (${systemWidth}px) exceeds renderer width (${rendererWidth}px)`,
      };
    } else if (totalWidth + systemWidth > rendererWidth) {
      return {
        token: AUTH_TOKEN,
        type: 'newline',
        system,
      };
    } else {
      return {
        token: AUTH_TOKEN,
        type: 'accepted',
        system,
      };
    }
  }

  /** Accepts the outcome by adding the proposal to this line. */
  accept(outcome: AcceptedProposalOutcome): void {
    this.check(outcome);
    this.systems.push(outcome.system);
  }

  /** Stretches systems to fill the renderer width and returns a new line. */
  newline(outcome: NewlineProposalOutcome): Line {
    this.check(outcome);

    const rendererWidth = this.factory.getRendererWidth();
    const totalWidth = this.getTotalWidth();
    const remainingWidth = rendererWidth - totalWidth;

    let truncatedWidth = 0;
    for (let ndx = 0; ndx < this.systems.length; ndx++) {
      const system = this.systems[ndx];

      // We want to increase the widths proportionally to what they were pre-fit.
      const systemProportion = this.getSystemWidth(system) / totalWidth;

      // We can't use a fraction of pixels, which makes this an approximation.
      const approxWidth = remainingWidth * systemProportion;

      const isLastSystem = ndx === this.systems.length - 1;
      if (isLastSystem) {
        this.resize(system, Math.round(approxWidth + truncatedWidth));
      } else {
        this.resize(system, Math.trunc(approxWidth));
        truncatedWidth += approxWidth % 1;
      }
    }

    return new Line(this.factory, [outcome.system]);
  }

  private check(outcome: ProposalOutcome): void {
    if (outcome.token !== AUTH_TOKEN) {
      throw new Error('use Line.propose to generate an authentic outcome');
    }
  }

  private getSystemWidth(system: vexflow.System): number {
    const box = system.getBoundingBox();
    if (box) {
      return box.getW();
    } else {
      return this.factory.Formatter().preCalculateMinTotalWidth(system.getVoices());
    }
  }

  private getTotalWidth(): number {
    let width = 0;
    for (const system of this.systems) {
      width += this.getSystemWidth(system);
    }
    return width;
  }

  private resize(system: vexflow.System, width: number): void {
    system.setOptions({
      x: system.getX(),
      y: system.getY(),
      width,
      factory: this.factory,
    });

    for (const stave of system.getStaves()) {
      stave.setWidth(width);
    }
  }
}
